#include <cstdint>
#include <queue>
#include <unordered_multiset>

#include "cache.h"
#include "saturating_counter.h"

using namespace cnt;

#define ISSUED_QUEUE_SIZE 128

// The prefetcher distance. The cache line offset is computed as 2^d.
saturating_counter<0, 3> m_distance{0};

// A queue of recently issued prefetches. Used to determine if a prefetch was
// useful.
std::unordered_multiset<uint16_t> m_issued;
std::queue<uint16_t> m_issued_queue;

// Number of useful prefetches within a given interval. A prefetch is useful if
// the cache line is accessed after the prefetch.
saturating_counter<0, THRESHOLD> m_useful{0};
saturating_counter<0, 511> m_access{0};

void CACHE::l1d_prefetcher_initialize() {
    cout << "CPU " << cpu << " L1D next line prefetcher" << endl;
    m_issued.reserve(ISSUED_QUEUE_SIZE);
}

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip,
                                   uint8_t cache_hit, uint8_t type) {
    // A cache line was accessed.
    ++m_access;

    // Check if a prefetch was already issued.
    uint64_t cache_line = addr >> LOG2_BLOCK_SIZE;
    bool is_issued = m_issued.count(cache_line);

    // If a prefetch was already issued, then the prefetch is useful.
    if (is_issued) ++m_useful;

    // If the monitoring interval is over, increase the distance if the
    // prefetches have been useful, otherwise, decrease the distance.
    if (m_access == m_access.max()) {
        if (m_useful == m_useful.max())
            ++m_distance;
        else
            --m_distance;
        m_access = 0;
        m_useful = 0;
    }

    // Compute the prefetch address.
    uint64_t offset = 1 << m_distance;
    uint64_t pf_cache_line = cache_line + offset;
    uint64_t pf_addr = pf_cache_line << LOG2_BLOCK_SIZE;

    // Do not repeat recent prefetches.
    bool pf_is_issued = m_issued.count(pf_cache_line);
    if (pf_is_issued) return;

    // Maintain queue of prefetched cache lines.
    m_issued.insert(pf_cache_line);
    m_issued_queue.push(pf_cache_line);
    if (m_issued_queue.size() > ISSUED_QUEUE_SIZE) {
        m_issued.erase(m_issued.find(m_issued_queue.front()));
        m_issued_queue.pop();
    }

    prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way,
                                      uint8_t prefetch, uint64_t evicted_addr,
                                      uint32_t metadata_in) {}

void CACHE::l1d_prefetcher_final_stats() {
    cout << "CPU " << cpu << " L1D next line prefetcher final stats" << endl;
}

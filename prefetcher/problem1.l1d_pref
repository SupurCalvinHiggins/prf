#include <cstdint>
#include <queue>
#include <unordered_set>

#include "cache.h"

// L1 data prefetcher
// idea
// buffer 128 prefetched block addresses (store 16 lsb of block addr)
// within last 512 accesses, how many hits?
//

#define MAX_PREFETCH_BUF_SIZE 128
#define INTERVAL 512
#define THRESHOLD 16

uint8_t m_distance;
std::queue<uint16_t> m_prefetch_buf;
std::unordered_set<uint16_t> m_prefetch_set;

uint64_t m_hits;
uint64_t m_time;

void CACHE::l1d_prefetcher_initialize() {
    cout << "CPU " << cpu << " L1D next line prefetcher" << endl;
    m_distance = 0;
    m_prefetch_set.reserve(MAX_PREFETCH_BUF_SIZE);
    m_hits = 0;
    m_time = 0;
}

// what do we want to know from history?
// add to history
//
// hits in interval
// was prefetched before
//

// called when a tag is checked in the cache
// this means (1) data is requested from cache, or (2) tag checked for coherence
// address
// instruction pointer
// cache hit (y/n)
// type (load, write, read for ownership, prefetch, translation)
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip,
                                   uint8_t cache_hit, uint8_t type) {
    uint64_t cl = addr >> LOG2_BLOCK_SIZE;
    bool is_already_prefetched = m_prefetch_set.count(cl);
    if (is_already_prefetched) {
        ++m_hits;
    }
    ++m_time;
    if (m_time == INTERVAL) {
        if (m_hits >= THRESHOLD) {
            if (m_distance < 128) ++m_distance;
        } else {
            if (m_distance > 0) --m_distance;
        }
    }
    if (is_already_prefetched) {
        return;
    }

    uint64_t pf_cl = cl + 1 + m_distance;
    uint64_t pf_addr = pf_cl << LOG2_BLOCK_SIZE;

    // Maintain queue of prefetched cache lines.
    m_prefetch_buf.push(pf_cl);
    m_prefetch_set.insert(pf_cl);
    if (m_prefetch_buf.size() > MAX_PREFETCH_BUF_SIZE) {
        m_prefetch_set.erase(m_prefetch_buf.front());
        m_prefetch_buf.pop();
    }

    DP(if (warmup_complete[cpu]) {
        cout << "[" << NAME << "] " << __func__ << hex
             << " base_cl: " << (addr >> LOG2_BLOCK_SIZE);
        cout << " pf_cl: " << (pf_addr >> LOG2_BLOCK_SIZE) << " ip: " << ip
             << " cache_hit: " << +cache_hit << " type: " << +type << endl;
    });

    prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
}

// called when a miss is filled in the cache
// address
// set, way of fill (way is # ways if bypass)
// prefetch (if addr was generated by prefetcher)
// evicted_addr addr of evicted block
void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way,
                                      uint8_t prefetch, uint64_t evicted_addr,
                                      uint32_t metadata_in) {}

void CACHE::l1d_prefetcher_final_stats() {
    cout << "CPU " << cpu << " L1D next line prefetcher final stats" << endl;
}

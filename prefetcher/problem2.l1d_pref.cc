#include <cstdint>
#include <queue>
#include <unordered_set>

#include "cache.h"

// L1 data prefetcher
// idea
// buffer 128 prefetched block addresses (store 16 lsb of block addr)
// within last 512 accesses, how many hits?
//

#define MAX_PREFETCH_BUF_SIZE 128
#define INTERVAL 512
#define THRESHOLD 16

uint8_t m_distance;
std::queue<uint16_t> m_prefetch_buf;
std::unordered_set<uint16_t> m_prefetch_set;

uint64_t m_hits;
uint64_t m_time;

void CACHE::l1d_prefetcher_initialize() {
    cout << "CPU " << cpu << " L1D next line prefetcher" << endl;
    m_distance = 0;
    m_prefetch_set.reserve(MAX_PREFETCH_BUF_SIZE);
    m_hits = 0;
    m_time = 0;
}

// what do we want to know from history?
// add to history
//
// hits in interval
// was prefetched before
//

// called when a tag is checked in the cache
// this means (1) data is requested from cache, or (2) tag checked for coherence
// address
// instruction pointer
// cache hit (y/n)
// type (load, write, read for ownership, prefetch, translation)
//
//
//
// potential improvements:
// stride: not super important (blocks handle this?)
// track delta between addr issues from same ip
// aggresiveness (degree)
// distance
//
// track late/not late (on time / used prefetches), accurate/not accurate (used
// prefetches / all prefetches), polluting/not polluting, coverage (prefetch
// misses / all misses)
// can also track # of cycles over 100 L1 accesses. if # of cycles decreases
// when increasing aggressiveness, its good, otherwise, its bad
//
//
// if increasing aggresiveness does not help, and hits are very low, turn off?
//
//
// plan:
// identify several potentially useful metrics. write code to track them.
// see if they are useful (try all combinations).
//
//
// Timeliness is the percentage of useful prefetches that are timely (arrive
// before use). Track two values:
// 1. The number of useful prefetches. TODO
// 2. The number of timely prefetches. TODO
//
// Accuracy is the percentage of useful prefetches. Track two values:
// 1. The number of useful prefetches. TODO
// 2. The number of prefetches. TODO
//
// Coverage is the percentage of misses that are prefetched. Track two values:
// 1. The number of misses. TODO.
// 2. The number of misses that are prefetched. TODO.
//
// Instructions per access is the average number of cycles per cache
// access. Track two values:
// 1. The number of cycles. TODO
// 2. The number of cache accesses. TODO
//
// Access coverage is the percentage of accesses that are prefetched. Track two
// values:
// 1. The number of accesses. TODO.
// 2. The number of prefetched accesses. TODO.

// Do not prefetch writes?. we want to focus on minimizing load misses
// writes are buffered already

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip,
                                   uint8_t cache_hit, uint8_t type) {
    uint64_t cl = addr >> LOG2_BLOCK_SIZE;
    bool is_already_prefetched = m_prefetch_set.count(cl);
    if (is_already_prefetched) {
        ++m_hits;
    }
    ++m_time;
    if (m_time == INTERVAL) {
        if (m_hits >= THRESHOLD) {
            if (m_distance < 128) ++m_distance;
        } else {
            if (m_distance > 0) --m_distance;
        }
    }
    if (is_already_prefetched) {
        return;
    }

    uint64_t pf_cl = cl + 1 + m_distance;
    uint64_t pf_addr = pf_cl << LOG2_BLOCK_SIZE;

    // Maintain queue of prefetched cache lines.
    m_prefetch_buf.push(pf_cl);
    m_prefetch_set.insert(pf_cl);
    if (m_prefetch_buf.size() > MAX_PREFETCH_BUF_SIZE) {
        m_prefetch_set.erase(m_prefetch_buf.front());
        m_prefetch_buf.pop();
    }

    prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
}

// called when a miss is filled in the cache
// address
// set, way of fill (way is # ways if bypass)
// prefetch (if addr was generated by prefetcher)
// evicted_addr addr of evicted block
void CACHE::l1d_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way,
                                      uint8_t prefetch, uint64_t evicted_addr,
                                      uint32_t metadata_in) {}

void CACHE::l1d_prefetcher_final_stats() {
    cout << "CPU " << cpu << " L1D next line prefetcher final stats" << endl;
}
